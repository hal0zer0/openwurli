"""Generate Rust source file with baked MLP weights from model_weights.json.

Reads the exported JSON and writes a Rust file with const arrays that
mlp_correction.rs includes. No file I/O or dependencies at runtime.

Usage:
    python generate_rust_weights.py
    python generate_rust_weights.py --input ml_data/model_weights.json \
        --output ../crates/openwurli-dsp/src/mlp_weights.rs
"""

import argparse
import json
import os


def format_array_1d(values, indent=4):
    """Format a 1D array as Rust initializer."""
    prefix = " " * indent
    items = [f"{v:.17e}" for v in values]
    lines = []
    line = prefix
    for i, item in enumerate(items):
        sep = ", " if i < len(items) - 1 else ","
        candidate = line + item + sep
        if len(candidate) > 100 and line.strip():
            lines.append(line.rstrip())
            line = prefix + item + sep
        else:
            line = candidate
    if line.strip():
        lines.append(line.rstrip())
    return "\n".join(lines)


def format_array_2d(values, indent=4):
    """Format a 2D array as Rust initializer (array of arrays)."""
    prefix = " " * indent
    rows = []
    for row in values:
        inner = ", ".join(f"{v:.17e}" for v in row)
        rows.append(f"{prefix}[{inner}],")
    return "\n".join(rows)


def generate_rust_weights(weights_path, output_path):
    """Generate Rust const arrays from trained model weights."""
    with open(weights_path) as f:
        data = json.load(f)

    layers = data["layers"]
    assert len(layers) == 3, f"Expected 3 layers, got {len(layers)}"
    assert layers[0]["activation"] == "relu"
    assert layers[1]["activation"] == "relu"
    assert layers[2]["activation"] == "linear"

    input_size = data["input_size"]
    hidden_size = data["hidden_size"]
    output_size = data["output_size"]

    w1 = layers[0]["weights"]  # [hidden][input]
    b1 = layers[0]["bias"]     # [hidden]
    w2 = layers[1]["weights"]  # [hidden][hidden]
    b2 = layers[1]["bias"]     # [hidden]
    w3 = layers[2]["weights"]  # [output][hidden]
    b3 = layers[2]["bias"]     # [output]

    assert len(w1) == hidden_size and len(w1[0]) == input_size
    assert len(b1) == hidden_size
    assert len(w2) == hidden_size and len(w2[0]) == hidden_size
    assert len(b2) == hidden_size
    assert len(w3) == output_size and len(w3[0]) == hidden_size
    assert len(b3) == output_size

    target_means = data["target_means"]
    target_stds = data["target_stds"]

    n_params = (hidden_size * input_size + hidden_size +
                hidden_size * hidden_size + hidden_size +
                output_size * hidden_size + output_size)

    rust_src = f"""\
// Generated by ml/generate_rust_weights.py -- DO NOT EDIT
//
// MLP for per-note parameter corrections.
// Architecture: Input({input_size}) -> Dense({hidden_size}, ReLU) -> Dense({hidden_size}, ReLU) -> Dense({output_size}, Linear)
// Total parameters: {n_params}
//
// Output vector (22 dims):
//   [0:7]   amp_offsets   H2-H8 (dB, positive = model too quiet)
//   [7:14]  freq_offsets  H2-H8 (cents)
//   [14:21] decay_offsets H2-H8 (ratio, >1 = model decays too fast)
//   [21]    d0_correction (multiplier for displacement_scale)

pub const HIDDEN_SIZE: usize = {hidden_size};

// Layer 1: Input({input_size}) -> Hidden({hidden_size}), ReLU
pub const W1: [[f64; {input_size}]; {hidden_size}] = [
{format_array_2d(w1, 4)}
];
pub const B1: [f64; {hidden_size}] = [
{format_array_1d(b1, 4)}
];

// Layer 2: Hidden({hidden_size}) -> Hidden({hidden_size}), ReLU
pub const W2: [[f64; {hidden_size}]; {hidden_size}] = [
{format_array_2d(w2, 4)}
];
pub const B2: [f64; {hidden_size}] = [
{format_array_1d(b2, 4)}
];

// Layer 3: Hidden({hidden_size}) -> Output({output_size}), Linear
pub const W3: [[f64; {hidden_size}]; {output_size}] = [
{format_array_2d(w3, 4)}
];
pub const B3: [f64; {output_size}] = [
{format_array_1d(b3, 4)}
];

// Target denormalization (mean/std from training data)
pub const TARGET_MEANS: [f64; {output_size}] = [
{format_array_1d(target_means, 4)}
];
pub const TARGET_STDS: [f64; {output_size}] = [
{format_array_1d(target_stds, 4)}
];
"""

    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    with open(output_path, "w") as f:
        f.write(rust_src)

    print(f"Generated {output_path}")
    print(f"  Architecture: {input_size} -> {hidden_size} -> {hidden_size} -> {output_size}")
    print(f"  Parameters: {n_params}")


def main():
    parser = argparse.ArgumentParser(description="Generate Rust weight arrays from MLP weights")
    parser.add_argument("--input", default="ml_data/model_weights.json",
                        help="Path to model_weights.json")
    parser.add_argument("--output",
                        default="../crates/openwurli-dsp/src/mlp_weights.rs",
                        help="Output Rust source path")
    args = parser.parse_args()

    script_dir = os.path.dirname(os.path.abspath(__file__))
    input_path = os.path.join(script_dir, args.input)
    output_path = os.path.join(script_dir, args.output)

    generate_rust_weights(input_path, output_path)


if __name__ == "__main__":
    main()
